
Какой самый эффективный способ конкатенации строк?
ответ: strings.Builder
// Объявляем переменную типа strings.Builder
var sb strings.Builder

// Запускаем цикл и пишем строку в Builder
for i := 0; i < 1000; i++ {
sb.WriteString("a")
}
// Вызываем метод преобразования в строку аккумулированных данных из объекта sb
fmt.Println(sb.String())

Что такое интерфейсы, как они применяются в Go?
ответ: Интерфейсы — это в первую очередь контракты.
Они позволяют объектам опираться на абстракции, а не фактические реализации других объектов.
При этом для компоновки различных поведений можно группировать несколько интерфейсов.
В общем смысле — это набор методов, представляющих стандартное поведение для различных типов данных.

Чем отличаются RWMutex от Mutex?
ответ: RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать.
Например, стандартный тип map.

Чем отличаются буферизированные и не буферизированные каналы?
ответ: Небуферизированный канал всегда блокирует горутину, до чтения\записи
Буферизированный канал не всегда блокирует горутину.
В буферизированный канал можно писать до конца буфера, без блокировки.
А блокировка будет вызвана только записью сверх буфера.

Какой размер у структуры struct{}{}?
ответ: 0 байт

Есть ли в Go перегрузка методов или операторов?
ответ: У методов и операторов нет перегрузки.

В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0] = 1
m[1] = 124
m[2] = 281
ответ: тип map неупорядоченный тип, поэтому, если мы будем в цикле(range ) пройдемся и выведем элементы мапы,
каждый раз они выведуться в разном порядке.
если вывести  через println упорядочно то есть ключи 0, 1, 2 в том же порядке они и выведуться.

В чем разница make и new?
ответ: make выделяет память и возвращает саму сущность создаваемую make-ом и работает только с картой, срезом и каналами
new выделяет память и возвращает указатель на сущность.в случае со срезом и картой len и cap будут 0

Сколько существует способов задать переменную типа slice или map?
ответ: make и инициировать в ручную

Что выведет данная программа и почему?

func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
ответ: программа выведет 1 1, потому что если, бы мы хотели вернуть новое значение,
нужно было бы переделать функцию подобным образом:
func update(p *int) *int {
	b := 2
	p = &b
	return p
}
Что выведет данная программа и почему?

func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
ответ: будет дедлок, потому что нужно вэйтгруппу передавать по указателю:
func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
Что выведет данная программа и почему?

func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
ответ: выведется 0.
Программа может содержать несколько объявлений одного и того же имени при условии,
что все объявления находятся в различных лексических блоках
func main() {
	n := 0 // на уровне пакета объявлена
	if true {
		n := 1 //объявлена и изолирована другим блоком
		n++
	}
	fmt.Println(n)
}

Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
	v[0] = 100       // 1 меняется на 100
	v = append(v, b) // так как капасити не хватит создастся новый слайс и капасити увеличится в двое
}

func main() {
	var a = []int8{1, 2, 3, 4, 5} // len=5 capacity=5
	someAction(a, 6)
	fmt.Println(a)
}

ответ: [100 2 3 4 5]
Что выведет данная программа и почему?

func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		// slice(len=2, capacity=2)[a,a]
		slice = append(slice, "a") // slice(len=3, capacity=4)[a, a, a]
		slice[0] = "b"             //[b, a, a]
		slice[1] = "b"             //[b, b, a]
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice) // [a, a]
}
ответ: [b b a][a a]
